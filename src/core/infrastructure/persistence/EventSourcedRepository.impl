#!/bin/sh
# EventSourcedRepository.impl - Repository using event sourcing
# Single Responsibility: Aggregate persistence via events
# POSIX Compliance: Uses event store and aggregates

# FIX: Get absolute path to this script's directory
if [ -n "${BASH_SOURCE:-}" ]; then
    _repo_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
elif [ -n "${ZSH_VERSION:-}" ]; then
    _repo_dir="$(cd "$(dirname "${(%):-%x}")" && pwd)"
else
    # POSIX fallback - try to find project root
    _repo_dir="$(cd "$(dirname "$0")" 2>/dev/null && pwd)" || _repo_dir="."
fi

# Source dependencies with absolute paths
. "${_repo_dir}/../../domain/aggregates/UserAggregate.impl"
. "${_repo_dir}/../event-store/FileEventStore.impl"

# Save aggregate (no-op in event sourcing)
event_sourced_repository_save() {
    _aggregate_id="${1:-}"
    [ -z "$_aggregate_id" ] && return 1
    return 0
}

# Load aggregate by ID (replays events)
event_sourced_repository_load() {
    _aggregate_id="${1:-}"
    [ -z "$_aggregate_id" ] && return 1
    
    _event_count=$(event_store_count "$_aggregate_id")
    
    if [ "$_event_count" = "0" ]; then
        return 1
    fi
    
    user_aggregate_load "$_aggregate_id" || return 1
    return 0
}

# Find aggregate by ID and return state
event_sourced_repository_find_by_id() {
    _aggregate_id="${1:-}"
    [ -z "$_aggregate_id" ] && return 1
    
    event_sourced_repository_load "$_aggregate_id" || return 1
    user_aggregate_get_state "$_aggregate_id"
}

# Check if aggregate exists
event_sourced_repository_exists() {
    _aggregate_id="${1:-}"
    [ -z "$_aggregate_id" ] && return 1
    
    _event_count=$(event_store_count "$_aggregate_id")
    [ "$_event_count" != "0" ]
}

# Get all aggregates of type
event_sourced_repository_find_all() {
    _event_ids=$(event_store_get_by_aggregate_type "User")
    
    printf "%s\n" "$_event_ids" | while IFS= read -r _event_id; do
        [ -z "$_event_id" ] && continue
        base_event_get_aggregate_id "$_event_id"
    done | sort -u
}

# Count aggregates
event_sourced_repository_count() {
    event_sourced_repository_find_all | wc -l | tr -d ' '
}

# Get aggregate version
event_sourced_repository_get_version() {
    _aggregate_id="${1:-}"
    
    [ -z "$_aggregate_id" ] && {
        printf "0"
        return 0
    }
    
    user_aggregate_get_version "$_aggregate_id"
}

# Load at specific version
event_sourced_repository_load_at_version() {
    _aggregate_id="${1:-}"
    _version="${2:-}"
    
    [ -z "$_aggregate_id" ] && return 1
    [ -z "$_version" ] && return 1
    
    _user_aggregate_init || return 1
    
    event_stream_replay_to_version "$_aggregate_id" "$_version" "user_aggregate_apply_event"
}
