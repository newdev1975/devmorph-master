#!/bin/sh
# Implementation: ServiceRegistry.impl
# Description: Service registry for the DI container using shell abstraction

# Description: Initialize service registry using shell abstraction
# Parameters: None
# Returns: 0 on success, 1 on failure
service_registry_init() {
    # Check if required variables are set (from container initialization)
    if [ -z "$DI_REGISTRY_DIR" ]; then
        log_error "service_registry_init: DI_REGISTRY_DIR not set, container not initialized"
        return 1
    fi
    
    # Ensure registry directory exists
    if ! command -v mkdir >/dev/null 2>&1; then
        log_error "mkdir command not available"
        return 1
    fi
    
    mkdir -p "$DI_REGISTRY_DIR" || return 1
    
    return 0
}

# Description: Add a service binding to the registry
# Parameters:
#   $1 - interface name
#   $2 - implementation
#   $3 - lifetime type (singleton|transient|scoped)
# Returns: 0 on success, 1 on failure
service_registry_add() {
    if [ $# -lt 2 ]; then
        log_error "service_registry_add: interface name and implementation required"
        return 1
    fi
    
    if [ -z "$1" ] || [ -z "$2" ]; then
        log_error "service_registry_add: interface name and implementation cannot be empty"
        return 1
    fi
    
    interface_name="$1"
    implementation="$2"
    lifetime="${3:-transient}"  # Default to transient if not specified
    
    # Validate lifetime parameter
    case "$lifetime" in
        "singleton"|"transient"|"scoped")
            # Valid lifetime type
            ;;
        *)
            log_error "service_registry_add: invalid lifetime '$lifetime', must be singleton, transient, or scoped"
            return 1
            ;;
    esac
    
    # Validate interface name format (alphanumeric with underscores and hyphens)
    if ! printf "%s" "$interface_name" | grep -E '^[a-zA-Z0-9_-]+$' >/dev/null 2>&1; then
        log_error "service_registry_add: invalid interface name format: $interface_name"
        return 1
    fi
    
    # Validate implementation format (alphanumeric with underscores, hyphens, dots, slashes)
    if ! printf "%s" "$implementation" | grep -E '^[a-zA-Z0-9_.\-/]+$' >/dev/null 2>&1; then
        log_error "service_registry_add: invalid implementation format: $implementation"
        return 1
    fi
    
    # Store binding using shell abstraction
    binding_file="$DI_REGISTRY_DIR/$interface_name"
    printf "%s:%s" "$implementation" "$lifetime" > "$binding_file" || return 1
    
    # Add to the list of registered interfaces
    registered_list_file="$DI_REGISTRY_DIR/.registered_interfaces"
    if [ -f "$registered_list_file" ]; then
        # Check if interface is already in the list
        if ! grep -Fxq "$interface_name" "$registered_list_file" 2>/dev/null; then
            echo "$interface_name" >> "$registered_list_file"
        fi
    else
        echo "$interface_name" > "$registered_list_file"
    fi
    
    return 0
}

# Description: Get a service binding from the registry
# Parameters:
#   $1 - interface name
# Returns: 0 on success, 1 on failure
# Output: binding information in format "implementation:lifetime"
service_registry_get() {
    if [ $# -lt 1 ] || [ -z "$1" ]; then
        log_error "service_registry_get: interface name required"
        return 1
    fi
    
    interface_name="$1"
    binding_file="$DI_REGISTRY_DIR/$interface_name"
    
    # Check if binding exists
    if [ ! -f "$binding_file" ]; then
        log_error "service_registry_get: interface '$interface_name' not registered"
        return 1
    fi
    
    # Read binding data
    binding_data=$(cat "$binding_file")
    if [ -z "$binding_data" ]; then
        log_error "service_registry_get: empty binding for '$interface_name'"
        return 1
    fi
    
    echo "$binding_data"
    return 0
}

# Description: Check if an interface is registered in the registry
# Parameters:
#   $1 - interface name
# Returns: 0 if registered, 1 if not
service_registry_has() {
    if [ $# -lt 1 ] || [ -z "$1" ]; then
        return 1
    fi
    
    interface_name="$1"
    binding_file="$DI_REGISTRY_DIR/$interface_name"
    
    [ -f "$binding_file" ]
}

# Description: Remove a service binding from the registry
# Parameters:
#   $1 - interface name
# Returns: 0 on success, 1 on failure
service_registry_remove() {
    if [ $# -lt 1 ] || [ -z "$1" ]; then
        log_error "service_registry_remove: interface name required"
        return 1
    fi
    
    interface_name="$1"
    binding_file="$DI_REGISTRY_DIR/$interface_name"
    
    if [ -f "$binding_file" ]; then
        rm "$binding_file" || return 1
        
        # Remove from registered interfaces list
        registered_list_file="$DI_REGISTRY_DIR/.registered_interfaces"
        if [ -f "$registered_list_file" ]; then
            if command -v grep >/dev/null 2>&1; then
                grep -v "^$interface_name$" "$registered_list_file" > "$registered_list_file.tmp" 2>/dev/null
                mv "$registered_list_file.tmp" "$registered_list_file" 2>/dev/null
            fi
        fi
    else
        log_error "service_registry_remove: interface '$interface_name' not registered"
        return 1
    fi
    
    return 0
}

# Description: Get all registered interface names
# Parameters: None
# Returns: 0 on success
# Output: List of registered interface names
service_registry_get_all_interfaces() {
    registered_list_file="$DI_REGISTRY_DIR/.registered_interfaces"
    if [ -f "$registered_list_file" ]; then
        cat "$registered_list_file"
    else
        # Fallback: get all files in registry directory
        for file in "$DI_REGISTRY_DIR"/*; do
            if [ -f "$file" ] && [ "$(basename "$file")" != ".registered_interfaces" ]; then
                basename "$file"
            fi
        done
    fi
}

# Description: Clear all bindings from the registry
# Parameters: None
# Returns: 0 on success, 1 on failure
service_registry_clear() {
    if [ -d "$DI_REGISTRY_DIR" ]; then
        # Remove all binding files except the .registered_interfaces file
        find "$DI_REGISTRY_DIR" -type f ! -name '.registered_interfaces' -delete 2>/dev/null || {
            # Fallback for systems without find
            for file in "$DI_REGISTRY_DIR"/*; do
                if [ -f "$file" ] && [ "$(basename "$file")" != ".registered_interfaces" ]; then
                    rm "$file" || return 1
                fi
            done
        }
        
        # Clear the registered interfaces list
        registered_list_file="$DI_REGISTRY_DIR/.registered_interfaces"
        if [ -f "$registered_list_file" ]; then
            > "$registered_list_file"  # Truncate the file
        fi
    fi
    
    return 0
}